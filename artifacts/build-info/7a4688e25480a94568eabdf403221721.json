{
	"id": "7a4688e25480a94568eabdf403221721",
	"_format": "hh-sol-build-info-1",
	"solcVersion": "0.8.23",
	"solcLongVersion": "0.8.23+commit.f704f362",
	"input": {
		"language": "Solidity",
		"sources": {
			"083WriteToAnySlot-TransparentUpgradeableProxy.sol": {
				"content": "\n\n/*\n1. 课程⽬标 \n    • 学习如何在Solidity智能合约中写⼊任意存储槽 \n    • 将实现合约地址和管理员地址存储在新的存储槽中\n2. 基础知识 \n    • Solidity智能合约的存储结构 \n        ◦ 存储是⼀个2^256⼤⼩的数组，每个槽可以存储32字节 \n    • keccak256哈希函数 \n    • 使⽤结构体和库\n3. 实践内容 \n    • 移除实现合约和管理员地址的旧存储位置\n        ◦ 从Counter B1和Counter B2合约中移除实现合约和管理员地址 \n    • 创建新的库和合约来测试存储槽的写⼊\n        ◦ 创建⼀个名为 StorageSlot 的库\n        ◦ 创建⼀个测试合约 TestSlot\n4. 库的实现 \n    • 创建结构体 AddressSlot ⽤于存储地址\n    • 编写函数getAddressSlot\n1\n    • 来获取存储槽的指针\n        ◦ 使⽤汇编语⾔获取存储指针\n        ◦ 函数的可⻅性和状态修饰符调整\n5. 测试合约 \n    • 定义存储槽常量\n        ◦ 使⽤ keccak256 哈希函数⽣成存储槽\n    • 编写getter和setter函数 \n        ◦ 获取和设置存储槽中的地址\n6. 应⽤到代理合约 \n    • 重命名代理合约\n    • 定义新的存储槽⽤于实现合约和管理员地址\n        ◦ 使⽤ keccak256 ⽣成存储槽并减⼀以避免哈希碰撞\n    • 编写getter和setter函数 \n        ◦ getAdmin 和 getImplementation\n        ◦ setAdmin 和 setImplementation\n7. 部署和测试 \n    • 部署新的代理合约\n    • 测试getter和setter函数 \n        ◦ 验证实现合约和管理员地址的存储和读取\n8. 总结与预告 \n    • 复习如何在任意存储槽中存储地址\n    • 预告下⼀部分内容：如何分离⽤⼾接⼝和管理员接⼝\n\n    \n编程作业 \n编写⼀个简单的Solidity合约，包含以下功能： \n1. 定义⼀个存储槽⽤于存储字符串：\n◦ 使⽤ keccak256 哈希函数⽣成存储槽\n◦ 定义结构体 StringSlot 包含⼀个字符串字段\n2. 编写getter和setter函数： \n◦ setStringSlot(string memory newValue) ：将字符串存储到指定槽中\n◦ getStringSlot() public view returns (string memory) ：从指定槽中读取字\n符串\n3. 测试合约：\n◦ 部署合约并调⽤setter函数存储字符串 \n◦ 调⽤getter函数验证存储的字符串是否正确\n\n\n*/ "
			}
		},
		"settings": {
			"optimizer": {
				"enabled": false,
				"runs": 200
			},
			"outputSelection": {
				"*": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"metadata",
						"devdoc",
						"userdoc",
						"storageLayout",
						"evm.legacyAssembly",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"evm.gasEstimates",
						"evm.assembly"
					]
				}
			},
			"remappings": []
		}
	},
	"output": {
		"errors": [
			{
				"component": "general",
				"errorCode": "1878",
				"formattedMessage": "Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n--> 083WriteToAnySlot-TransparentUpgradeableProxy.sol\n\n",
				"message": "SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.",
				"severity": "warning",
				"sourceLocation": {
					"end": -1,
					"file": "083WriteToAnySlot-TransparentUpgradeableProxy.sol",
					"start": -1
				},
				"type": "Warning"
			},
			{
				"component": "general",
				"errorCode": "3420",
				"formattedMessage": "Warning: Source file does not specify required compiler version! Consider adding \"pragma solidity ^0.8.23;\"\n--> 083WriteToAnySlot-TransparentUpgradeableProxy.sol\n\n",
				"message": "Source file does not specify required compiler version! Consider adding \"pragma solidity ^0.8.23;\"",
				"severity": "warning",
				"sourceLocation": {
					"end": -1,
					"file": "083WriteToAnySlot-TransparentUpgradeableProxy.sol",
					"start": -1
				},
				"type": "Warning"
			}
		],
		"sources": {
			"083WriteToAnySlot-TransparentUpgradeableProxy.sol": {
				"ast": {
					"absolutePath": "083WriteToAnySlot-TransparentUpgradeableProxy.sol",
					"exportedSymbols": {},
					"id": 1,
					"nodeType": "SourceUnit",
					"nodes": [],
					"src": "2339:0:0"
				},
				"id": 0
			}
		}
	}
}